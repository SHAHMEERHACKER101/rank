/**
 * NexusRank Pro - Cloudflare Worker
 * AI-powered SEO toolkit backend service
 * Proxies requests to DeepSeek AI API with proper CORS and security
 */

// CORS configuration for multiple origins
function getCorsHeaders(origin) {
  const allowedOrigins = [
    'https://nexusrankpro.pages.dev',
    'http://localhost:5000',
    'http://127.0.0.1:5000'
  ];
  
  const isAllowed = allowedOrigins.includes(origin) || origin?.includes('nexusrankpro.pages.dev');
  
  return {
    'Access-Control-Allow-Origin': isAllowed ? origin : 'https://nexusrankpro.pages.dev',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Max-Age': '86400',
  };
}

// DeepSeek API configuration
const DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions';

// AI tool endpoints and their configurations
const AI_ENDPOINTS = {
  '/ai/seo-write': {
    name: 'AI SEO Writer',
    systemPrompt: 'You are a professional SEO content writer. Write comprehensive, SEO-optimized articles that rank well in search engines. Use proper H2/H3 headings, bullet points, natural keyword integration, and maintain a human tone throughout. Avoid AI writing patterns and create engaging, valuable content.',
  },
  '/ai/humanize': {
    name: 'AI Humanizer',
    systemPrompt: 'You are an expert at making AI-generated text sound completely human-written. Transform the given text to sound 100% human by adding contractions, natural language patterns, slight imperfections, conversational flow, and removing all AI-like patterns. Make it completely undetectable as AI content.',
  },
  '/ai/detect': {
    name: 'AI Detector',
    systemPrompt: 'You are an AI detection specialist. Analyze the given text and estimate the probability that it was generated by AI. Look for patterns like repetitive phrasing, unnatural transitions, overly perfect grammar, lack of personal experience, generic statements, and AI-typical structures. Respond with "AI Probability: X%" followed by a brief 2-sentence explanation.',
  },
  '/ai/paraphrase': {
    name: 'Paraphrasing Tool',
    systemPrompt: 'You are a professional text rewriter. Completely rewrite the given text to be 100% unique and undetectable as AI-generated content. Maintain the original meaning while changing sentence structure, vocabulary, and flow. Ensure the result sounds natural and human-written with varied sentence lengths and natural transitions.',
  },
  '/ai/grammar': {
    name: 'Grammar Checker',
    systemPrompt: 'You are a professional editor and grammar expert. Fix all grammar, spelling, punctuation, and style errors in the given text. Improve clarity and readability while maintaining the original voice and meaning. Return only the corrected text without any explanations, annotations, or markup.',
  },
  '/ai/improve': {
    name: 'Text Improver',
    systemPrompt: 'You are a professional writing coach. Enhance the given text for better clarity, fluency, and professionalism. Improve readability, flow, and engagement while preserving the core message and meaning. Make the text more compelling and polished without changing its fundamental intent.',
  },
};

/**
 * Main worker event listener - ES Module syntax (preferred)
 */
export default {
  async fetch(request, env, ctx) {
    return handleRequest(request, env);
  }
};

/**
 * Fallback for service worker syntax (for older deployments)
 */
if (typeof addEventListener !== 'undefined') {
  addEventListener('fetch', event => {
    event.respondWith(handleRequest(event.request, globalThis));
  });
}

/**
 * Handle incoming requests
 */
async function handleRequest(request, env) {
  const url = new URL(request.url);
  const path = url.pathname;
  const origin = request.headers.get('Origin');
  const corsHeaders = getCorsHeaders(origin);

  // Handle CORS preflight requests
  if (request.method === 'OPTIONS') {
    return handleCors(corsHeaders);
  }

  // Health check endpoint
  if (path === '/health' && request.method === 'GET') {
    return new Response(JSON.stringify({ 
      status: 'healthy', 
      timestamp: new Date().toISOString(),
      service: 'NexusRank Pro AI Worker',
      hasApiKey: !!(env?.DEEPSEEK_API_KEY || globalThis.DEEPSEEK_API_KEY),
      envType: typeof env,
      envKeys: env ? Object.keys(env) : []
    }), {
      headers: { 
        'Content-Type': 'application/json',
        ...corsHeaders 
      }
    });
  }

  // Process AI tool requests
  if (AI_ENDPOINTS[path] && request.method === 'POST') {
    return handleAIRequest(request, path, env, corsHeaders);
  }

  // Return 404 for unknown endpoints
  return new Response(JSON.stringify({ 
    error: 'Endpoint not found',
    path: path,
    availableEndpoints: Object.keys(AI_ENDPOINTS)
  }), {
    status: 404,
    headers: { 
      'Content-Type': 'application/json',
      ...corsHeaders 
    }
  });
}

/**
 * Handle CORS preflight requests
 */
function handleCors(corsHeaders) {
  return new Response(null, {
    status: 204,
    headers: corsHeaders
  });
}

/**
 * Handle AI processing requests
 */
async function handleAIRequest(request, endpoint, env, corsHeaders) {
  try {
    // Get DeepSeek API key from environment (supports both module and service worker syntax)
    const apiKey = env?.DEEPSEEK_API_KEY || globalThis.DEEPSEEK_API_KEY || process?.env?.DEEPSEEK_API_KEY;
    console.log('Environment debug:', { 
      hasEnv: !!env, 
      hasApiKey: !!apiKey,
      envType: typeof env,
      envKeys: env ? Object.keys(env) : [],
      globalHasDeepseek: 'DEEPSEEK_API_KEY' in globalThis,
      processEnvExists: !!process?.env
    });
    
    if (!apiKey) {
      console.error('No API key found in any environment source');
      return createErrorResponse('AI service configuration error. API key not found.', 500, corsHeaders);
    }

    // Parse request body
    const body = await request.json();
    const { prompt, text } = body;

    if (!prompt && !text) {
      return createErrorResponse('Missing required field: prompt or text', 400, corsHeaders);
    }

    const inputText = prompt || text;
    if (typeof inputText !== 'string' || inputText.trim().length === 0) {
      return createErrorResponse('Input text must be a non-empty string', 400, corsHeaders);
    }

    // Validate input length (max 50k characters for safety)
    if (inputText.length > 50000) {
      return createErrorResponse('Input text is too long. Maximum 50,000 characters allowed.', 400, corsHeaders);
    }

    // Get endpoint configuration
    const endpointConfig = AI_ENDPOINTS[endpoint];
    
    // Construct the full prompt for DeepSeek
    const fullPrompt = `${endpointConfig.systemPrompt}\n\nText to process:\n${inputText}`;

    // Call DeepSeek API
    const aiResponse = await callDeepSeekAPI(apiKey, fullPrompt);
    
    if (!aiResponse.success) {
      return createErrorResponse(aiResponse.error, 500, corsHeaders);
    }

    // Return successful response
    return new Response(JSON.stringify({
      success: true,
      content: aiResponse.content,
      tool: endpointConfig.name,
      timestamp: new Date().toISOString()
    }), {
      headers: { 
        'Content-Type': 'application/json',
        ...corsHeaders 
      }
    });

  } catch (error) {
    console.error('AI Request Error:', error);
    return createErrorResponse('Internal server error. Please try again.', 500, corsHeaders);
  }
}

/**
 * Call DeepSeek API
 */
async function callDeepSeekAPI(apiKey, prompt) {
  try {
    const response = await fetch(DEEPSEEK_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'deepseek-chat',
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 4000,
        temperature: 0.7,
        top_p: 0.9,
        frequency_penalty: 0.1,
        presence_penalty: 0.1,
        stream: false
      })
    });

    if (!response.ok) {
      const errorData = await response.text();
      console.error('DeepSeek API Error:', response.status, errorData);
      
      if (response.status === 401) {
        return { success: false, error: 'AI service authentication failed' };
      } else if (response.status === 429) {
        return { success: false, error: 'AI service rate limit exceeded. Please try again later.' };
      } else if (response.status >= 500) {
        return { success: false, error: 'AI service temporarily unavailable. Please try again.' };
      } else {
        return { success: false, error: 'AI service request failed' };
      }
    }

    const data = await response.json();
    
    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      return { success: false, error: 'Invalid response from AI service' };
    }

    const content = data.choices[0].message.content;
    if (!content || content.trim().length === 0) {
      return { success: false, error: 'AI service returned empty response' };
    }

    return { 
      success: true, 
      content: content.trim() 
    };

  } catch (error) {
    console.error('DeepSeek API Call Error:', error);
    return { 
      success: false, 
      error: 'Failed to connect to AI service. Please check your connection and try again.' 
    };
  }
}

// Environment variable access is now handled directly through the env parameter

/**
 * Create standardized error response
 */
function createErrorResponse(message, status = 400, corsHeaders) {
  return new Response(JSON.stringify({
    success: false,
    error: message,
    timestamp: new Date().toISOString()
  }), {
    status: status,
    headers: { 
      'Content-Type': 'application/json',
      ...(corsHeaders || getCorsHeaders()) 
    }
  });
}

/**
 * Rate limiting helper (basic implementation)
 * In production, you might want to use Cloudflare KV or Durable Objects for more sophisticated rate limiting
 */
class RateLimiter {
  constructor() {
    this.requests = new Map();
    this.windowMs = 60000; // 1 minute
    this.maxRequests = 100; // per window
  }

  isAllowed(clientId) {
    const now = Date.now();
    const windowStart = now - this.windowMs;
    
    if (!this.requests.has(clientId)) {
      this.requests.set(clientId, []);
    }
    
    const clientRequests = this.requests.get(clientId);
    
    // Remove old requests outside the window
    const recentRequests = clientRequests.filter(timestamp => timestamp > windowStart);
    this.requests.set(clientId, recentRequests);
    
    // Check if limit exceeded
    if (recentRequests.length >= this.maxRequests) {
      return false;
    }
    
    // Add current request
    recentRequests.push(now);
    return true;
  }
}

// Global rate limiter instance
const rateLimiter = new RateLimiter();

/**
 * Enhanced request handler with rate limiting
 */
async function handleRequestWithRateLimit(request, env) {
  // Get client identifier (IP address or CF-Connecting-IP header)
  const clientId = request.headers.get('CF-Connecting-IP') || 
                   request.headers.get('X-Forwarded-For') || 
                   'unknown';
  
  const origin = request.headers.get('Origin');
  const corsHeaders = getCorsHeaders(origin);
  
  // Check rate limit
  if (!rateLimiter.isAllowed(clientId)) {
    return createErrorResponse('Rate limit exceeded. Please try again later.', 429, corsHeaders);
  }
  
  return handleRequest(request, env);
}
