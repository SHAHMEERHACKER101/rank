/**
 * NexusRank Pro - Cloudflare Worker
 * AI-powered SEO toolkit backend service
 * Proxies requests to DeepSeek AI API with proper CORS and security
 */

// CORS headers for frontend communication
const CORS_HEADERS = {
  'Access-Control-Allow-Origin': 'https://nexusrank-pro.pages.dev',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
  'Access-Control-Max-Age': '86400',
};

// DeepSeek API configuration
const DEEPSEEK_API_URL = 'https://api.deepseek.com/v1/chat/completions';

// AI tool endpoints and their configurations
const AI_ENDPOINTS = {
  '/ai/seo-write': {
    name: 'AI SEO Writer',
    systemPrompt: 'You are a professional SEO content writer. Write comprehensive, SEO-optimized articles that rank well in search engines. Use proper H2/H3 headings, bullet points, natural keyword integration, and maintain a human tone throughout. Avoid AI writing patterns and create engaging, valuable content.',
  },
  '/ai/humanize': {
    name: 'AI Humanizer',
    systemPrompt: 'You are an expert at making AI-generated text sound completely human-written. Transform the given text to sound 100% human by adding contractions, natural language patterns, slight imperfections, conversational flow, and removing all AI-like patterns. Make it completely undetectable as AI content.',
  },
  '/ai/detect': {
    name: 'AI Detector',
    systemPrompt: 'You are an AI detection specialist. Analyze the given text and estimate the probability that it was generated by AI. Look for patterns like repetitive phrasing, unnatural transitions, overly perfect grammar, lack of personal experience, generic statements, and AI-typical structures. Respond with "AI Probability: X%" followed by a brief 2-sentence explanation.',
  },
  '/ai/paraphrase': {
    name: 'Paraphrasing Tool',
    systemPrompt: 'You are a professional text rewriter. Completely rewrite the given text to be 100% unique and undetectable as AI-generated content. Maintain the original meaning while changing sentence structure, vocabulary, and flow. Ensure the result sounds natural and human-written with varied sentence lengths and natural transitions.',
  },
  '/ai/grammar': {
    name: 'Grammar Checker',
    systemPrompt: 'You are a professional editor and grammar expert. Fix all grammar, spelling, punctuation, and style errors in the given text. Improve clarity and readability while maintaining the original voice and meaning. Return only the corrected text without any explanations, annotations, or markup.',
  },
  '/ai/improve': {
    name: 'Text Improver',
    systemPrompt: 'You are a professional writing coach. Enhance the given text for better clarity, fluency, and professionalism. Improve readability, flow, and engagement while preserving the core message and meaning. Make the text more compelling and polished without changing its fundamental intent.',
  },
};

/**
 * Main worker event listener
 */
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

/**
 * Handle incoming requests
 */
async function handleRequest(request) {
  const url = new URL(request.url);
  const path = url.pathname;

  // Handle CORS preflight requests
  if (request.method === 'OPTIONS') {
    return handleCors();
  }

  // Health check endpoint
  if (path === '/health' && request.method === 'GET') {
    return new Response(JSON.stringify({ 
      status: 'healthy', 
      timestamp: new Date().toISOString(),
      service: 'NexusRank Pro AI Worker'
    }), {
      headers: { 
        'Content-Type': 'application/json',
        ...CORS_HEADERS 
      }
    });
  }

  // Process AI tool requests
  if (AI_ENDPOINTS[path] && request.method === 'POST') {
    return handleAIRequest(request, path);
  }

  // Return 404 for unknown endpoints
  return new Response(JSON.stringify({ 
    error: 'Endpoint not found',
    path: path,
    availableEndpoints: Object.keys(AI_ENDPOINTS)
  }), {
    status: 404,
    headers: { 
      'Content-Type': 'application/json',
      ...CORS_HEADERS 
    }
  });
}

/**
 * Handle CORS preflight requests
 */
function handleCors() {
  return new Response(null, {
    status: 204,
    headers: CORS_HEADERS
  });
}

/**
 * Handle AI processing requests
 */
async function handleAIRequest(request, endpoint) {
  try {
    // Get DeepSeek API key from environment
    const apiKey = getEnvVar('DEEPSEEK_API_KEY');
    if (!apiKey) {
      return createErrorResponse('AI service configuration error. Please contact support.', 500);
    }

    // Parse request body
    const body = await request.json();
    const { prompt, text } = body;

    if (!prompt && !text) {
      return createErrorResponse('Missing required field: prompt or text', 400);
    }

    const inputText = prompt || text;
    if (typeof inputText !== 'string' || inputText.trim().length === 0) {
      return createErrorResponse('Input text must be a non-empty string', 400);
    }

    // Validate input length (max 50k characters for safety)
    if (inputText.length > 50000) {
      return createErrorResponse('Input text is too long. Maximum 50,000 characters allowed.', 400);
    }

    // Get endpoint configuration
    const endpointConfig = AI_ENDPOINTS[endpoint];
    
    // Construct the full prompt for DeepSeek
    const fullPrompt = `${endpointConfig.systemPrompt}\n\nText to process:\n${inputText}`;

    // Call DeepSeek API
    const aiResponse = await callDeepSeekAPI(apiKey, fullPrompt);
    
    if (!aiResponse.success) {
      return createErrorResponse(aiResponse.error, 500);
    }

    // Return successful response
    return new Response(JSON.stringify({
      success: true,
      content: aiResponse.content,
      tool: endpointConfig.name,
      timestamp: new Date().toISOString()
    }), {
      headers: { 
        'Content-Type': 'application/json',
        ...CORS_HEADERS 
      }
    });

  } catch (error) {
    console.error('AI Request Error:', error);
    return createErrorResponse('Internal server error. Please try again.', 500);
  }
}

/**
 * Call DeepSeek API
 */
async function callDeepSeekAPI(apiKey, prompt) {
  try {
    const response = await fetch(DEEPSEEK_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: 'deepseek-chat',
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 4000,
        temperature: 0.7,
        top_p: 0.9,
        frequency_penalty: 0.1,
        presence_penalty: 0.1,
        stream: false
      })
    });

    if (!response.ok) {
      const errorData = await response.text();
      console.error('DeepSeek API Error:', response.status, errorData);
      
      if (response.status === 401) {
        return { success: false, error: 'AI service authentication failed' };
      } else if (response.status === 429) {
        return { success: false, error: 'AI service rate limit exceeded. Please try again later.' };
      } else if (response.status >= 500) {
        return { success: false, error: 'AI service temporarily unavailable. Please try again.' };
      } else {
        return { success: false, error: 'AI service request failed' };
      }
    }

    const data = await response.json();
    
    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      return { success: false, error: 'Invalid response from AI service' };
    }

    const content = data.choices[0].message.content;
    if (!content || content.trim().length === 0) {
      return { success: false, error: 'AI service returned empty response' };
    }

    return { 
      success: true, 
      content: content.trim() 
    };

  } catch (error) {
    console.error('DeepSeek API Call Error:', error);
    return { 
      success: false, 
      error: 'Failed to connect to AI service. Please check your connection and try again.' 
    };
  }
}

/**
 * Get environment variable with fallback
 */
function getEnvVar(name, fallback = null) {
  try {
    return globalThis[name] || process?.env?.[name] || fallback;
  } catch (error) {
    return fallback;
  }
}

/**
 * Create standardized error response
 */
function createErrorResponse(message, status = 400) {
  return new Response(JSON.stringify({
    success: false,
    error: message,
    timestamp: new Date().toISOString()
  }), {
    status: status,
    headers: { 
      'Content-Type': 'application/json',
      ...CORS_HEADERS 
    }
  });
}

/**
 * Rate limiting helper (basic implementation)
 * In production, you might want to use Cloudflare KV or Durable Objects for more sophisticated rate limiting
 */
class RateLimiter {
  constructor() {
    this.requests = new Map();
    this.windowMs = 60000; // 1 minute
    this.maxRequests = 100; // per window
  }

  isAllowed(clientId) {
    const now = Date.now();
    const windowStart = now - this.windowMs;
    
    if (!this.requests.has(clientId)) {
      this.requests.set(clientId, []);
    }
    
    const clientRequests = this.requests.get(clientId);
    
    // Remove old requests outside the window
    const recentRequests = clientRequests.filter(timestamp => timestamp > windowStart);
    this.requests.set(clientId, recentRequests);
    
    // Check if limit exceeded
    if (recentRequests.length >= this.maxRequests) {
      return false;
    }
    
    // Add current request
    recentRequests.push(now);
    return true;
  }
}

// Global rate limiter instance
const rateLimiter = new RateLimiter();

/**
 * Enhanced request handler with rate limiting
 */
async function handleRequestWithRateLimit(request) {
  // Get client identifier (IP address or CF-Connecting-IP header)
  const clientId = request.headers.get('CF-Connecting-IP') || 
                   request.headers.get('X-Forwarded-For') || 
                   'unknown';
  
  // Check rate limit
  if (!rateLimiter.isAllowed(clientId)) {
    return createErrorResponse('Rate limit exceeded. Please try again later.', 429);
  }
  
  return handleRequest(request);
}

// Optional: Use rate-limited handler for production
// addEventListener('fetch', event => {
//   event.respondWith(handleRequestWithRateLimit(event.request));
// });
